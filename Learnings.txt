npm run dev 

1) How to setup a professional backend project
npm init
touch gitbash
.gitkeep
module.js
devdep dep
mkdir
prettier


2) How to connect database in MERN with debugging
no allow access from anywhere in production ip address 0.0.0.0/0
remove (/) from url of mongodb connection string
wrap db in try catch / promise when communicate
db is always another continent async await time lagta h
; before iffe in professional envirment
throw / process.exit
connection instance:log
dotenv = as early as possible in your application import and configure dotenv
nodemon -r dotenv/config --experimental-json-modules src/index.js


3) Custom api response and error handling
middleware's/configurations are used by app.use
CORS_ORIGIN = *
explore cors
//accepting json
app.use(express.json({limit:"16kb"}))
file uploading handles multer
its hard to extract data from url m+a/m%20a
cookie parser is used to perform crud ops on server
(err, req, res, next)
repeating code is written in utils like trycatch and async await of db
higher order function treats functions like variables
node.js api error
this.data
Informational responses (100 – 199)
Successful responses (200 – 299)
Redirection messages (300 – 399)
Client error responses (400 – 499)
Server error responses (500 – 599)


4) User and video model with hooks and JWT
mongodata save user in bson data

JSON (JavaScript Object Notation) is the human-readable data interchange format you interact with, while BSON (Binary JSON) is the internal, binary-encoded format that MongoDB uses for efficient storage and high performance

When you insert a JSON document into MongoDB, the database automatically converts it to BSON for storage. When you query data, the drivers convert the retrieved BSON back into JSON-like objects (e.g., Python dictionaries, JavaScript objects) in your application.

"User" will become plural and lowercase --> "users"
to make field searchable in db make index true
timestamps:true makes createdAt and updatedAt
mongoose-aggregate-paginate-v2
bcrypt jwt
pre hook : runs just before saving data encrypt password
pre takes normal function because arrow func doest have this. property
methods .compare
jwt is a bearer token => who owns data given like a key (secure)
refresh token payload has less data because of continuous refresh


5) How to upload file in backend | Multer
first take file from user and upload on server/local storage and then upload to cloudinary through multer because if user entered wrong file he has chance to edit

if file uploaded well remove from server too
server restart when env touched
multer middleware documentation
difference between multer disk and memory storage
multer, cors


6) HTTP crash course | http Methods | http headers
 url,uri,urn uniform resource locater/identifier
HTTP headers req, res
headers do caching, authentication(token, bearer), manage state
req head -> client
res head -> server
representation header -> encoding/compression
payload(fancy name of data) head -> data
most common headers -> accept, auth, cookie, content-type, cache
cors, security headers
optimize data structure to avoid delay of the user


7) Complete guide for router and controller with debugging
main route in app file and sub routes in user file
http://localhost:8000/api/v1/users/register
router.route("/register").post(registerUser)


8) Logic building | Register controller
multer upload.field
get user details from frontend depends on user model
  validation - !empty
  check if user already exist: username, email
  check for images, and avatar
  upload them to cloudinary, avatar
  create user object - create entry in db
  remove password and refresh token from res
  check for user creation
  return res

User.findOne({
    $or: [{ email }, { username }],
  });

some method, trim

multer gives req.files option
findById, select("-password -refreshToken")


9) How to use postman for backend
cloudinary response (url, secure_url)
log req.body, req.files [Object: null prototype]
cloudinary.js (fs.unlinkSync(localFilePath)) temporarily stores in local storage and synchronously deletes
findById, select("-password -refreshToken") no password and token in postman response
Array.isArray(req.files.coverImage)
bug resolved of coverImage = "" in userController 41
bug resolved of await User.findOne({}) in userController 41
cloudinary returns "" empty string when no coverImage
postman environment : {{server}}/users/register


10) Access Refresh Token, Middleware and cookies in Backend
access token short lived, refresh token long lived
access token for authentication/login/some features provide/15 min expires again provide password/expire in short duration
refresh token is saved in db and given to user / we validate user by access token but we say not to enter password again and again, an end point is hit and refresh tokens are compared by db one and new access token is generated 

loginUser Functionality
// req body -> data
  // validation form/req data (username or email base)
  // req db / find user
  // password check
  // access and refresh token and send to user
  // send in cookies secure
  // res === login

 $or: [{ username }, { email }], mongoDB operator

(User) is you created in model, (user) is retrieved from db

validateBeforeSave: false

// only modified by server not frontend
  // const options = {
  //   httpOnly: true,
  //   secure: true,
  // };


// loginUser controller
.json(
    //   new ApiResponse(
    //     200,

    //      data in api response
    //     {
    //       user: loggedInUser,
    //       accessToken,
    //       refreshToken,
    //     },
    //     "User logged In Successfully"
    //   )
    // );

Authorization Bearer Access Token
Auth middleware understand
Login user logout user controller, routes
if res not used in parameters so we can write _

11) Access token and refresh token in Backend

refreshAccessToken controller

access and refresh token work is to only help user not to enter password again and again
access token is timed, if expired 401 error
on frontend a code is written if 401 req hit an end point refresh access token
to get new access token a refresh token is send and compares if refresh token is same new access token generated and login successful
refresh token is saved in db and called when needed
user has encrypted token and db has raw token jwt

_id isn't in schema but default made by db so we can access though in code in userModel
options in refreshAccessToken controller
try catch for safety purpose


12) Writing update controllers for user
changeCurrentPasswordin user controller

subscription model
id user is logged in through middleware so we can get id of user from req.user
can add confirm password too

separate controllers for updating files production level approach
less network congestion

updateAccountDetails
new:true return updated value
mongoDB set method

update controllers
